import os
import random
import string
import csv
import datetime
import getpass
import uuid
from config import *

# ================== Setup th∆∞ m·ª•c ==================
os.makedirs(LOG_DIR, exist_ok=True)
os.makedirs(EXPORT_DIR, exist_ok=True)
os.makedirs(QUESTIONS_DIR, exist_ok=True)

# ================== Utils ==================
def timestamp_now():
    """Tr·∫£ v·ªÅ timestamp d·∫°ng YYYYMMDD_HHMMSS"""
    return datetime.datetime.now().strftime("%Y%m%d_%H%M%S")

def current_user():
    """L·∫•y user hi·ªán t·∫°i (n·∫øu l·ªói -> unknown_user)"""
    try:
        return getpass.getuser()
    except Exception:
        return "unknown_user"

def log_action(action: str, detail: str = ""):
    """Ghi log h√†nh ƒë·ªông v√†o file theo ng√†y"""
    ts = datetime.datetime.now().isoformat(sep=" ", timespec="seconds")
    fn = os.path.join(LOG_DIR, f"{datetime.datetime.now().strftime('%Y%m%d')}.log")
    line = f"{ts} | {current_user()} | {action} | {detail}\n"
    with open(fn, "a", encoding="utf-8") as f:
        f.write(line)

# ================== Core Game ==================
class QuizGame:
    def __init__(self, qdir=QUESTIONS_DIR):
        self.qdir = qdir
        os.makedirs(self.qdir, exist_ok=True)
        # self._categories = self._load_categories()
        self.color_map = self._build_color_map()

    # ----------------- File handling -----------------
    @staticmethod
    def clearsrc():
        """Clear m√†n h√¨nh console"""
        if CLEAR_SCREEN:
            os.system("cls" if os.name == "nt" else "clear")

    def _files(self):
        """Tr·∫£ v·ªÅ danh s√°ch file CSV trong th∆∞ m·ª•c"""
        return [f for f in os.listdir(self.qdir) if f.endswith(".csv")]

    def _list_files(self, show=True):
        """Li·ªát k√™ file trong th∆∞ m·ª•c, k√®m s·ªë l∆∞·ª£ng c√¢u h·ªèi"""
        files = self._files()
        if not files:
            print("‚ö†Ô∏è Kh√¥ng c√≥ file c√¢u h·ªèi.")
            return []

        if show:
            print(f"{BRIGHT_GREEN}\nüìÇ Danh s√°ch file:{RESET}")
            for i, f in enumerate(files, 1):
                path = os.path.join(self.qdir, f)
                try:
                    with open(path, encoding="utf-8-sig") as f_csv:
                        count = sum(1 for _ in csv.reader(f_csv)) - 1
                except Exception:
                    count = 0
                print(f" {i:>2}) {f:<25} | {count} c√¢u h·ªèi")
        return files

    def _choose_file(self, action="ch·ªçn"):
        """Ch·ªçn file t·ª´ danh s√°ch"""
        files = self._list_files()
        if not files:
            return
        try:
            i = input(f"\nüëâ Nh·∫≠p ID ƒë·ªÉ {action}: ")
            return os.path.join(self.qdir, files[int(i) - 1]) if i.isdigit() and 0 < int(i) <= len(files) else None
        except:
            print("‚ö†Ô∏è Ch·ªçn kh√¥ng h·ª£p l·ªá.")

    def _load(self, path):
        """ƒê·ªçc file CSV -> list(tuple)"""
        if not os.path.exists(path):
            return []
        with open(path, encoding="utf-8-sig") as f:
            return [(r["id"], r["answer"], r["question"], r["desc"], r["ref"]) for r in csv.DictReader(f)]

    def _save(self, path, data):
        """Ghi d·ªØ li·ªáu v√†o file CSV (sort theo ƒë√°p √°n)"""
        data_sorted = sorted(data, key=lambda x: x[1].lower())
        with open(path, "w", encoding="utf-8-sig", newline="") as f:
            writer = csv.writer(f)
            writer.writerow(["id", "answer", "question", "desc", "ref"])
            writer.writerows(data_sorted)

    def _show(self, path):
        """In danh s√°ch c√¢u h·ªèi trong file"""
        data = self._load(path)
        if not data:
            print("‚ùå File tr·ªëng.")
            return []

        print("\nüìã DANH S√ÅCH C√ÇU H·ªéI:")
        for i, (_, a, q, d, r) in enumerate(data, 1):
            q_disp, a_disp, d_disp, r_disp = (self._normalize_all(x) for x in (q, a, d, r))
            print(f"{BRIGHT_CYAN}{i:>2})==========\n‚ùì\tC√¢u h·ªèi: {RESET}{q_disp}")
            print(f"{GREEN}‚û§\tƒê√°p √°n: {RESET}{a_disp}")
            for label, val, color in [
                (f"{YELLOW}üí°\tM√¥ t·∫£: {RESET}", d_disp, YELLOW),
                (f"{CYAN}üîó\tReference: {RESET}", r_disp, CYAN),
            ]:
                if val:
                    print(f"{color}{label} {val}{RESET}")
        return data

    # ----------------- CRUD c√¢u h·ªèi -----------------
    def _crud(self, mode):
        """Thao t√°c CRUD tr√™n c√¢u h·ªèi"""
        path = self._choose_file(mode)
        if not path:
            return
        data = self._show(path)

        def save_and_log(action, msg):
            self._save(path, data)
            log_action(action, f"{os.path.basename(path)} | {msg}")

        if mode == "th√™m":
            while True:
                self.clearsrc()
                self._show(path)
                q = input(f"\n‚ùì Nh·∫≠p c√¢u h·ªèi (ho·∫∑c nh·∫≠p exit() ƒë·ªÉ tho√°t):{RESET} ").strip()
                if q.lower() == "exit()": break
                a = input(f"‚úÖ Nh·∫≠p ƒë√°p √°n (ho·∫∑c nh·∫≠p exit() ƒë·ªÉ tho√°t):{RESET}: ").strip()
                if a.lower() == "exit()": break
                if not q or not a:
                    continue
                d = input("üí° M√¥ t·∫£ (c√≥ th·ªÉ b·ªè tr·ªëng): ").strip()
                r = input("üîó Reference (c√≥ th·ªÉ b·ªè tr·ªëng): ").strip()
                data.append((str(uuid.uuid4()), a, q, d, r))
                save_and_log("ADD_Q", f"Q: {q}")
                print("‚ûï ƒê√£ th√™m c√¢u h·ªèi m·ªõi.")

        elif mode == "xo√°":
            while True:
                self.clearsrc()
                self._show(path)
                idx = input(f"\nüóëÔ∏è {BRIGHT_GREEN}Nh·∫≠p ID (ho·∫∑c nh·∫≠p {BRIGHT_RED}exit(){BRIGHT_GREEN} ƒë·ªÉ tho√°t):{RESET} ").strip()
                if idx.lower() == "exit()": break
                if idx.isdigit() and 1 <= int(idx) <= len(data):
                    removed = data.pop(int(idx) - 1)
                    save_and_log("DEL_Q", f"Q: {removed[2]}")
                    print(f"üóëÔ∏è ƒê√£ xo√°: {removed[2]}")
                else:
                    print("‚ùå ID kh√¥ng h·ª£p l·ªá.")

        elif mode.startswith("s·ª≠a"):
            field_map = {"s·ª≠aQ": 2, "s·ª≠aA": 1, "s·ª≠aD": 3, "s·ª≠aR": 4}
            while True:
                self.clearsrc()
                self._show(path)
                idx = input(f"\nüî¢ {BRIGHT_GREEN}Nh·∫≠p ID (ho·∫∑c nh·∫≠p {BRIGHT_RED}exit(){BRIGHT_GREEN} ƒë·ªÉ tho√°t):{RESET} ").strip()
                if idx.lower() == "exit()": break
                if idx.isdigit() and 1 <= int(idx) <= len(data):
                    entry = list(data[int(idx) - 1])
                    if mode == "s·ª≠a":
                        entry[2] = input("‚ùì C√¢u h·ªèi m·ªõi: ").strip() or entry[2]
                        entry[1] = input("‚úÖ ƒê√°p √°n m·ªõi: ").strip() or entry[1]
                        entry[3] = input("üí° M√¥ t·∫£ m·ªõi: ").strip() or entry[3]
                        entry[4] = input("üîó Reference m·ªõi: ").strip() or entry[4]
                    else:
                        field_idx = field_map[mode]
                        new_val = input(f"‚úèÔ∏è Nh·∫≠p gi√° tr·ªã m·ªõi (c≈©: {entry[field_idx]}): ").strip()
                        if new_val:
                            entry[field_idx] = new_val
                    data[int(idx) - 1] = tuple(entry)
                    save_and_log("EDIT_Q", f"{entry}")
                    print("‚úÖ ƒê√£ s·ª≠a th√†nh c√¥ng.")

    # ----------------- Game logic -----------------
        # ----------------- Game logic -----------------
    def _options(self, correct, pool, n):
        """Sinh ra danh s√°ch ƒë√°p √°n l·ª±a ch·ªçn"""
        pool = list(set(pool) - {correct, "ƒê√∫ng", "Sai"})
        return random.sample(pool, min(n - 1, len(pool))) + [correct]

    @staticmethod
    def _progress_bar(percent, width=30):
        """Hi·ªÉn th·ªã progress bar"""
        filled = int(width * percent // 100)
        return "[" + "=" * filled + " " * (width - filled) + f"] {percent:.1f}%"
    
    @staticmethod
    def _build_color_map():
        """T·∫°o map {TOKEN} -> ANSI t·ª´ config"""
        import config
        return {
            f"{{{k}}}": v
            for k, v in vars(config).items()
            if k.isupper() and isinstance(v, str) and v.startswith(f"\033")
        }
    
    def _normalize_all(self, text, max_passes=1):
        """Chu·∫©n h√≥a \n, \t v√† thay {COLOR} -> ANSI (l·∫∑p nhi·ªÅu l·∫ßn n·∫øu c·∫ßn)"""
        if not text:
            return text
        last = None
        passes = 0
        while text != last and passes < max_passes:
            last = text
            # B1: chu·∫©n h√≥a k√Ω t·ª± ƒë·∫∑c bi·ªát
            text = text.replace("\\n", "\n").replace("\\t", "\t").replace(".\n", "\n")
            # B2: thay token m√†u
            for token, ansi in self.color_map.items():
                text = text.replace(token, ansi)
            passes += 1
        return text
    
    def _get_options(self, q, a, data, all_ans, n_opts):
        ql = q.lower()

        if "nh·∫≠n ƒë·ªãnh ƒë√∫ng sai" in ql:
            return ["ƒê√∫ng", "Sai"]

        special_map = KEYWORD
        for kw in special_map:
            if kw in ql:
                group = {a, *[ans for _, ans, ques, *_ in data if kw in ques.lower()]}
                opts = self._options(a, group, n_opts)
                return list(dict.fromkeys(self._normalize_all(opt) for opt in opts))
            
        opts = self._options(a, all_ans, n_opts)
        return list(dict.fromkeys(self._normalize_all(opt) for opt in opts))
        
        # return [self._normalize_all(opt) for opt in self._options(a, all_ans, n_opts)]

    def _feedback(self, ok, chosen, q, a, d, r, qid):
        """Hi·ªÉn th·ªã ph·∫£n h·ªìi sau khi tr·∫£ l·ªùi"""
        if ok:
            print(f"{GREEN}‚úÖ Ch√≠nh x√°c!{RESET}")
            log_action(f"CHOSEN:{qid}", f"{chosen} - {q} ƒê√∫ng + 1 ƒëi·ªÉm")
        else:
            print(f"{RED}‚ùå Sai!{RESET} ‚û§ ƒê√°p √°n ƒë√∫ng: {a}")
            log_action(f"CHOSEN:{qid}", f"{chosen} - {q} Sai")
        if d:
            print(f"{YELLOW}üí° M√¥ t·∫£: {d}{RESET}")
        if r:
            print(f"{CYAN}üîó Tham chi·∫øu:{r}{RESET}")

    def _export_results(self, results, score, total):
        """Xu·∫•t k·∫øt qu·∫£ quiz ra CSV"""
        wrong = total - score
        percent = (score / total * 100) if total else 0.0
        print("\n" + "=" * 60)
        print(f"{BLUE}üéØ B·∫¢NG ƒêI·ªÇM CHI TI·∫æT{RESET}")
        print(f"{'#':>3}  {'RESULT':^8}  {'CORRECT':^20}")
        print("-" * 60)
        for r in results:
            res_sym = f"{GREEN}‚úÖ{RESET}" if r["ok"] else f"{RED}‚ùå{RESET}"
            print(f"{r['index']:>3})  {res_sym:^8}   {r['correct']:<20}")
        print("-" * 60)
        print(f"{GREEN}‚úÖ ƒê√∫ng : {score}{RESET}    {RED}‚ùå Sai : {wrong}{RESET}    {CYAN}üìä T·ªâ l·ªá: {percent:.1f}%{RESET}")
        print(self._progress_bar(percent))

        # Xu·∫•t ra CSV
        csv_path = os.path.join(EXPORT_DIR, f"quiz_results_{timestamp_now()}.csv")
        with open(csv_path, "w", encoding="utf-8-sig", newline="") as f:
            w = csv.writer(f)
            w.writerow(["timestamp", datetime.datetime.now().isoformat()])
            w.writerow(["user", current_user()])
            w.writerow(["total_questions", total])
            w.writerow(["score", score])
            w.writerow(["wrong", wrong])
            w.writerow(["percent", f"{percent:.1f}"])
            w.writerow([])
            w.writerow(["idx", "question", "correct", "ok", "desc", "reference"])
            for r in results:
                w.writerow([r["index"], r["question"], r["correct"], r["ok"], r["desc"], r.get("ref", "")])
        print(f"{BRIGHT_GREEN}‚úÖ ƒê√£ export k·∫øt qu·∫£: {csv_path}{RESET}")

    def _ask_choice(self, mapping):
        """H·ªèi ng∆∞·ªùi ch∆°i ch·ªçn ƒë√°p √°n, tr·∫£ v·ªÅ l·ª±a ch·ªçn h·ª£p l·ªá"""
        while True:
            pick = input("üëâ Nh·∫≠p ƒë√°p √°n: ").lower().strip()
            if pick in mapping:
                return mapping[pick]
            print("‚ö†Ô∏è L·ª±a ch·ªçn kh√¥ng h·ª£p l·ªá, nh·∫≠p l·∫°i ƒëi!")
            log_action("CHOSEN", "Nh·∫≠p th·∫•t b·∫°i")

    def _check_answer(self, chosen, q, a, data):
        """Ki·ªÉm tra ƒë√°p √°n ng∆∞·ªùi ch∆°i ch·ªçn c√≥ ƒë√∫ng kh√¥ng""" 
        correct_answers = [ ans for _, ans, ques, *_ in data if ques.strip().lower() == q.strip().lower() ] 
        return chosen.lower() in (self._normalize_all(ca).lower() for ca in correct_answers)

    def _quiz(self, data, n_opts=None, max_qs=None):
        """Ch·∫°y quiz tr√™n dataset"""
        if not data:
            print("‚ùå Kh√¥ng c√≥ c√¢u h·ªèi.")
            return

        # üîÄ L·∫•y pool c√¢u h·ªèi (random + gi·ªõi h·∫°n n·∫øu c·∫ßn)
        pool = (data * ((max_qs // len(data)) + 1))[:max_qs] if max_qs else data
        if max_qs:
            random.shuffle(pool)

        all_ans = [a for _, a, _, _, _ in data]
        results, score = [], 0

        for i, (qid, a, q, d, r) in enumerate(pool, 1):
            print(f"\n" + "-" * 60)

            # Chu·∫©n h√≥a hi·ªÉn th·ªã

            """Chu·∫©n h√≥a \n, \t v√† m√†u (l·∫∑p nhi·ªÅu l·∫ßn n·∫øu c·∫ßn)"""
            # Chu·∫©n h√≥a \n, \t v√† m√†u (c√≥ th·ªÉ l·∫∑p nhi·ªÅu l·∫ßn n·∫øu c·∫ßn)
            # q_disp, a_disp, d_disp, r_disp, data_disp, all_ans_disp = (self._normalize_all(x, 40) for x in (q, a, d, r, data, all_ans))
            q_disp, a_disp, d_disp, r_disp = (self._normalize_all(x) for x in (q, a, d, r))
            print(f"{i}. ‚ùì {q_disp}\n")

            # T·∫°o l·ª±a ch·ªçn
            opts = self._get_options(q_disp, a_disp, data, all_ans, n_opts)
            random.shuffle(opts)
            mapping = dict(zip(string.ascii_lowercase, opts))
            for k, v in list(mapping.items())[:len(opts)]:
                print(f"{BRIGHT_GREEN}\t{k}){RESET} {v}{RESET}\n")

            # Ng∆∞·ªùi ch∆°i ch·ªçn
            chosen = self._ask_choice(mapping)

            # ‚úÖ Ki·ªÉm tra ƒë√∫ng/sai
            ok = self._check_answer(chosen, q, a_disp, data)
            if ok:
                score += 1

            results.append({
                "index": i, "question": q_disp, "correct": a_disp,
                "desc": d_disp, "ref": r_disp, "ok": ok
            })

            # Ph·∫£n h·ªìi
            self._feedback(ok, chosen, q_disp, a_disp, d_disp, r_disp, qid)

        # Xu·∫•t k·∫øt qu·∫£ cu·ªëi
        self._export_results(results, score, len(results))

    def play_file(self):
        """Ch∆°i quiz theo 1 file"""
        path = self._choose_file("ch∆°i")
        if path:
            self._quiz(self._load(path), n_opts=MAX_GENERATE_NORMAL_ANSWERS, max_qs=MAX_GENERATE_NORMAL_QUESTIONS)

    def play_all(self):
        """Ch∆°i quiz tr√™n t·∫•t c·∫£ file"""
        data = [q for f in self._files() for q in self._load(os.path.join(self.qdir, f))]
        self._quiz(data, n_opts=MAX_GENERATE_ALL_ANSWERS, max_qs=MAX_GENERATE_ALL_QUESTIONS)

    # ----------------- Menu -----------------
    def manage_questions(self):
        """Menu qu·∫£n l√Ω c√¢u h·ªèi"""
        actions = {
            "1": ("th√™m",   f"{BRIGHT_GREEN}‚ûï Th√™m n·ªôi dung{RESET}"),
            "2": ("xo√°",    f"{BRIGHT_RED}üóëÔ∏è Xo√° n·ªôi dung{RESET}"),
            "3": ("s·ª≠a",    f"{BRIGHT_YELLOW}‚úèÔ∏è S·ª≠a to√†n b·ªô n·ªôi dung{RESET}"),
            "4": ("s·ª≠aQ",   f"{BRIGHT_YELLOW}‚úèÔ∏è S·ª≠a c√¢u h·ªèi c·ª• th·ªÉ{RESET}"),
            "5": ("s·ª≠aA",   f"{BRIGHT_YELLOW}‚úèÔ∏è S·ª≠a ƒë√°p √°n c·ª• th·ªÉ{RESET}"),
            "6": ("s·ª≠aD",   f"{BRIGHT_YELLOW}‚úèÔ∏è S·ª≠a m√¥ t·∫£ c·ª• th·ªÉ{RESET}"),
            "7": ("s·ª≠aR",   f"{BRIGHT_YELLOW}‚úèÔ∏è S·ª≠a tham kh·∫£o c·ª• th·∫ª{RESET}"),
        }
        while True:
            self.clearsrc()
            print(f"\n{BRIGHT_CYAN}====={BRIGHT_GREEN} üìã QU·∫¢N L√ù N·ªòI DUNG  {RESET}{BRIGHT_CYAN}====={RESET}")
            print(f"\n{BRIGHT_GREEN}===\nC√°c ch·ª©c nƒÉng hi·ªán t·∫°i:\n{RESET}")
            [print(f"{BRIGHT_GREEN} {k}) {label}{RESET}") for k, (_, label) in actions.items()]
            print(f"\n{BRIGHT_GREEN}Ho·∫∑c nh·∫≠p {BRIGHT_RED}exit(){BRIGHT_GREEN} üîô quay l·∫°i{RESET}")
            ch = input(f"\n{BRIGHT_GREEN}üëâ Nh·∫≠p l·ª±a ch·ªçn: {RESET}").strip().lower()
            if ch == "exit()": 
                self.clearsrc()
                break
            if ch in actions: self._crud(actions[ch][0])
            else: print("‚ö†Ô∏è L·ª±a ch·ªçn kh√¥ng h·ª£p l·ªá.")

    def manage_files(self):
        """Menu qu·∫£n l√Ω file"""
        actions = {
            "1": ("CREATE_FILE", f"‚ûï {BRIGHT_GREEN}T·∫°o file{RESET}", self._create_file),
            "2": ("DELETE_FILE", f"üóëÔ∏è {BRIGHT_RED}Xo√° file{RESET}", self._delete_file),
            "3": ("RENAME_FILE", f"‚úèÔ∏è {BRIGHT_YELLOW}ƒê·ªïi t√™n file{RESET}", self._rename_file),
        }
        while True:
            try:
                self.clearsrc()
                print(f"\n{BRIGHT_CYAN}====={BRIGHT_GREEN} üìÇ QU·∫¢N L√ù FILE  {RESET}{BRIGHT_CYAN}====={RESET}")
                self._list_files()
                print(f"\n{BRIGHT_CYAN}===\nC√°c ch·ª©c nƒÉng hi·ªán t·∫°i:\n{RESET}")
                [print(f"{BRIGHT_CYAN} {k}) {label}{RESET}") for k, (_, label, _) in actions.items()]
                print(f"\n{BRIGHT_CYAN}Ho·∫∑c nh·∫≠p {BRIGHT_RED}exit(){BRIGHT_CYAN} üîô quay l·∫°i{RESET}")
                ch = input(f"\n{BRIGHT_CYAN}üëâ Nh·∫≠p l·ª±a ch·ªçn: {RESET}").strip().lower()
                if ch == "exit()": 
                    self.clearsrc()
                    break
                if ch in actions:
                    act, _, func = actions[ch]; func(act)
                else: print("‚ö†Ô∏è L·ª±a ch·ªçn kh√¥ng h·ª£p l·ªá.")
            except FileNotFoundError:
                break

    # ----------------- X·ª≠ l√Ω file -----------------
    def _create_file(self, act):
        """‚ûï T·∫°o file CSV m·ªõi"""
        name = input("üìÑ Nh·∫≠p t√™n file m·ªõi (kh√¥ng c·∫ßn .csv): ").strip()
        if not name: return
        path = os.path.join(self.qdir, f"{name}.csv")
        if os.path.exists(path):
            print("‚ö†Ô∏è File ƒë√£ t·ªìn t·∫°i.")
        else:
            with open(path, "w", encoding="utf-8-sig", newline="") as f:
                csv.writer(f).writerow(["id", "answer", "question", "desc", "ref"])
            log_action(act, path)
            print(f"‚úÖ ƒê√£ t·∫°o {name}.csv")

    def _delete_file(self, act):
        """üóëÔ∏è Xo√° file CSV ƒë√£ ch·ªçn"""
        if (path := self._choose_file("xo√°")) and input(f"‚ùì Xo√° {os.path.basename(path)} (y/n)\n> ").lower() == "y":
            os.remove(path); log_action(act, path)
            print("üóëÔ∏è ƒê√£ xo√° file.")

    def _rename_file(self, act):
        """‚úèÔ∏è ƒê·ªïi t√™n file CSV"""
        while True:
            if path := self._choose_file("ƒë·ªïi t√™n"):
                new = input("‚úèÔ∏è Nh·∫≠p t√™n m·ªõi (ho·∫∑c nh·∫≠p exit() ƒë·ªÉ tho√°t)\n> ").strip()
                log_action(f"CHANGE_Name")
                if new.lower() == "exit()": break
                if new:
                    newpath = os.path.join(self.qdir, f"{new}.csv")
                    os.rename(path, newpath)
                    log_action(act, f"{path} -> {newpath}")
                    print("‚úÖ ƒê√£ ƒë·ªïi t√™n file.")

    def menu(self):
        """Menu ch√≠nh ch∆∞∆°ng tr√¨nh"""
        actions = {
            "1": (self.play_file, f"{BRIGHT_GREEN}üéØ Ch∆°i theo b·ªô{RESET}"),
            "2": (self.play_all, f"{BRIGHT_GREEN}üåç Ch∆°i t·∫•t c·∫£{RESET}"),
            "3": (self.manage_questions, f"{BRIGHT_YELLOW}üìã Qu·∫£n l√Ω c√¢u h·ªèi{RESET}"),
            "4": (self.manage_files, f"{BRIGHT_YELLOW}üìÇ Qu·∫£n l√Ω file{RESET}"),
            "0": (lambda: print(f"{BRIGHT_RED}üëã T·∫°m bi·ªát!"), f"{BRIGHT_RED}üö™ Tho√°t{RESET}"),
        }
        while True:
            print(f"{BLUE}\n===== üìö FLASHCARD QUIZ GAME ====={RESET}")
            for k, (_, label) in actions.items():
                print(f" {k}) {label}")
            ch = input("\nüëâ Nh·∫≠p l·ª±a ch·ªçn: ").strip()
            if ch in actions:
                self.clearsrc()
                log_action("MENU", f"{ch}:{actions[ch][1]}")
                if ch == "0": return
                actions[ch][0]()
            else:
                self.clearsrc()
                print("‚ö†Ô∏è Sai l·ª±a ch·ªçn.")

# Entry point
if __name__ == "__main__":
    QuizGame().menu()
